### 什么是事务？

一组连续不可分割的SQL，要求要么全部成功要么全部撤销。

ex：银行转账 =>  A转1000块钱给B

1. A账户扣款1000元
2. B账户增加1000元

### 事务特性 ACID

1. 原子性(Atomic)：事务中的多个操作，不可分割，要么都成功，要么都失败。
2. 一致性(Consistency)：在执行之前和执行之后数据库都必须处于一致性状态，比如a,b账户相互转账之后，总金额不变。
3. 隔离性(Isolation)：由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。
4. 持久性(Durability)：事务结束后，将处理结果写入数据库文件中，即使机器宕机数据也不会丢失。

### 事务的并发问题

1. 脏读： 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
2. 不可重复读： 事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。
3. 幻读： 系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
4. 第一类丢失更新（Update Lost）：此种更新丢失是因为回滚的原因，所以也叫回滚丢失。此时两个事务同时更新count，两个事务都读取到100，事务一更新成功并提交，count=100+1=101，事务二出于某种原因更新失败了，然后回滚，事务二就把count还原为它一开始读到的100，此时事务一的更新就这样丢失了。
5. 第二类丢失更新（Second Update Lost）：此种更新丢失是因为更新被其他事务给覆盖了，也可以叫覆盖丢失。举个例子，两个事务同时更新count，都读取100这个初始值，事务一先更新成功并提交，count=100+1=101，事务二后更新成功并提交，count=100+1=101,由于事务二count还是从100开始增加，事务一的更新就这样丢失了。

### 事务隔离级别

1. 读未提交（read-uncommitted）       =>   指即使一个事务的更新语句没有提交,但是别的事务可以读到这个改变，几种异常情况都可能出现。极易出错，没有安全性可言，基本不会使用。
2. 读提交（read-committed）           =>   指一个事务只能看到其他事务的已经提交的更新，看不到未提交的更新，解决脏读
3. 可重复读（repeatable-read）- 默认   =>   指一个事务中进行两次或多次同样的对于数据内容的查询，得到的结果是一样的，但不保证对于数据条数的查询是一样的，只要存在读改行数据就禁止写，解决脏读，不可重复读
4. 串行化（serializable）             =>   解决脏读、可重复读、幻读，但效果最差，它将事务的执行变为顺序执行，只要存在读就禁止写， 但可以同时读，相当于单线程，后一个事务的执行必须等待前一个事务结束。

![mysql各种隔离级别对各异常的控制能力.png](../images/mysql各种隔离级别对各异常的控制能力.png)
