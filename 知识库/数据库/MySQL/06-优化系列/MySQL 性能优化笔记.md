# MySQL 性能优化笔记

### 1、选择合适的存储引擎: InnoDB (5.5版本之后默认内置InnoDB)
> 你自己在測试的时候可能会发现 MyISAM 比 InnoDB 速度快。
这是由于： MyISAM 仅仅缓存索引，而 InnoDB 缓存数据和索引，MyISAM 不支持事务。
可是 假设你使用 innodb_flush_log_at_trx_commit = 2 能够获得接近的读取性能 (相差百倍) 。

```mysql
# 查看mysql服务器版本
select version();

# 查看mysql提供的存储引擎  【 字段 Support为 `Default` 表示默认存储引擎 】
show engines;

# 查看mysql当前默认的存储引擎
show variables like '%storage_engine%';

# 查看指定表使用的存储引擎
show table status from 数据库名 where name='表名';
show create table 表名;

# 修改表引擎方法
alter table 表名 engine=innodb;

# ↓↓↓↓↓↓ 设置InnoDB为默认引擎 ↓↓↓↓↓↓
# 在配置文件my.cnf中的 [mysqld] 下面加入
default-storage-engine=INNODB
 
# 重启mysql服务器：
mysqladmin -u root -p shutdown 或者 service mysqld restart
```

### 2、保证从内存中读取数据，将数据保存在内存中 (即足够大的 innodb_buffer_pool_size)

```mysql
SHOW GLOBAL STATUS LIKE 'innodb_buffer_pool_pages_%';

# 如果发现 Innodb_buffer_pool_pages_free 为 0，则说明 buffer pool 已经被用光
```

### 3、实战之索引优化

```mysql

```

========================================================== ↓↓↓↓↓↓ MySQL ↓↓↓↓↓↓ ==========================================================

[3万字总结，Mysql优化之精髓](https://blog.csdn.net/xinzhifu1/article/details/104228470)

### 1、表设计 - [三范式](https://blog.csdn.net/weixin_43524620/article/details/86482149)
1. [X] 1NF: 确保每列的原子性(强调的是列的原子性，即列不能够再分成其他几列).如果每列(或者每个属性)都是不可再分的最小数据单元(也称为最小的原子单元),则满足第一范式.
        例如:顾客表(姓名、编号、地址、……)其中"地址"列还可以细分为国家、省、市、区等。
2. [X] 2NF: 在第一范式的基础上更进一层,目标是确保表中的每列都和主键相关(一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的部分)
            如果一个关系满足第一范式,并且除了主键以外的其它列,都依赖于该主键,则满足第二范式.
        例如:订单表(订单编号、产品编号、定购日期、价格、……)，"订单编号"为主键，"产品编号"和主键列没有直接的关系，即"产品编号"列不依赖于主键列，应删除该列。
3. [X] 3NF: 在第二范式的基础上更进一层,目标是确保每列都和主键列直接相关,而不是间接相关(另外非主键列必须直接依赖于主键，不能存在传递依赖).
            如果一个关系满足第二范式,并且除了主键以外的其它列都不依赖于主键列,则满足第三范式.
            为了理解第三范式，需要根据Armstrong公里之一定义传递依赖。假设A、B和C是关系R的三个属性，如果A-〉B且B-〉C，则从这些函数依赖中，可以得出A-〉C，如上所述，依赖A-〉C是传递依赖。
        例如:订单表(订单编号，定购日期，顾客编号，顾客姓名，……)，初看该表没有问题，满足第二范式，每列都和主键列"订单编号"相关，再细看你会发现"顾客姓名"和"顾客编号"相关，"顾客编号"和"订单编号"又相关，最后经过传递依赖，"顾客姓名"也和"订单编号"相关。为了满足第三范式，应去掉"顾客姓名"列，放入客户表中。
4. [ ] 巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）

反3NF: 允许存在冗余字段

总结:
1NF:原子性 列不可分割
2NF:记录具有唯一标识 通常通过主键实现
3NF:表中尽量不要有冗余数据,能够通过其他表推导出来的数据不要单独设置字段
---
反3NF:没有冗余的数据库表未必是最好的数据库表，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。
ex：单价和总价



### MySQL中索引类型:
普通索引（key），唯一索引（unique key），主键索引（primary key），全文索引（fulltext key）

1. 普通索引：允许重复的值出现，可以在任何字段上面添加
2. 唯一索引：除了不能有重复的记录外，其它和普通索引一样，可以在值是唯一的字段添加（用户名、手机号码、身份证、email，QQ），可以为null,并且可以有多个null
3. 主键索引：是随着设定主键而创建的，也就是把某个列设为主键的时候，数据库就会给该列创建索引。这就是主键索引.唯一且没有null值（也被称为非聚集索引）
4. 全文索引：用来对表中的文本域(char，varchar，text)进行索引， 全文索引针对MyISAM有用


### 索引检索为什么快？
关键字相对于数据本身，数据量小;关键字是有序的，二分查找可快速确定位置
ex: 图书馆为每本书都加了索引号（类别-楼层-书架）、字典为词语解释按字母顺序编写目录等都用到了索引。

### 查看索引
```mysql
SHOW CREATE TABLE 表名
-- 或
SHOW INDEX FROM 表名
```

### 创建索引

```mysql
-- 更改表结构
ALTER TABLE 表名
-- 创建一个`字段1`和`字段2`的复合索引
ADD KEY 索引名 (字段1,字段2),
-- 创建一个`字段3`的唯一索引，默认以字段名作为索引名
ADD UNIQUE KEY (字段3),
-- 全文索引不支持中文
ADD FULLTEXT KEY (字段4),
-- 使用B树作为索引, 备注xx
USING BTREE COMMENT 'xx索引';

-- 或
CREATE INDEX 索引名 ON 表名(字段名) USING BTREE COMMENT 'xx索引'; -- 普通索引
```

#### 满足以下条件的字段，才应该创建索引.
> [MySQL/Oracle数据库优化总结（非常全面）](https://blog.csdn.net/baidu_37107022/article/details/77460464)
1. 肯定在where条件经常使用 或者经常用来排序 order by后面的字段
2. 该字段的内容不是唯一的几个值(sex)
3. 字段内容不是频繁变化.
4. 不会出现在WHERE子句中字段不该创建索引
5. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描 (select id from t where num is null)
6. 最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库. (部分情况下可以设置默认值)
    备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL。
    不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。

### 索引失效
1. 复合索引 where查询的时候，复合索引中非第一个字段作为查询条件会失效（`最左前缀`特性），只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。
2. like查询的时候，以%开头 （like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。）
3. 应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描
4. 如果列字段类型为字符串查询条件时一定要使用单引号引起来，否则失效 （数字类型会自动转换为字符串类型，也就是，如果列是字符串类型，无论是不是字符串数字就一定要用 ‘’ 把它包括起来）
5. 排序的索引问题 （mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。）
6. 不要在列上进行运算 （select * from users where YEAR(adddate)<2007; 将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成  select * from users where adddate<‘2007-01-01';）
7. 不使用NOT IN ，!= 和<>操作（引擎会放弃使用索引而进行全表扫描。NOT IN可以NOT EXISTS代替，id<>3则可使用id>3 or id<3来代替。）

### 删除索引
根据索引名删除普通索引、唯一索引、全文索引
```mysql
ALTER TABLE 表名 DROP KEY 索引名
```

删除主键索引：
```mysql
ALTER TABLE 表名 DROP PRIMARY KEY -- （因为主键只有一个）。这里值得注意的是，如果主键自增长（ 主键定义为auto_increment时），那么不能直接执行此操作（自增长依赖于主键索引）：

-- 需要取消自增长再行删除：
ALTER TABLE 表名
-- 重新定义字段
MODIFY 主键id INT,
DROP PRIMARY KEY
```

### 索引的代价:
1. 占用磁盘空间。
2. 对dml操作有影响,因为要维护索引，变慢。

### sql调优 - 总结
- 列类型尽量定义成数值类型，且长度尽可能短，如主键和外键，类型字段等等
- 建立单列索引
- 根据需要建立多列联合索引
- 当单个列过滤之后还有很多数据，那么索引的效率将会比较低，即列的区分度较低。
- 如果在多个列上建立索引，那么多个列的区分度就大多了，将会有显著的效率提高。
- 根据业务场景建立覆盖索引只查询业务需要的字段，如果这些字段被索引覆盖，将极大的提高查询效率
- 多表连接的字段上需要建立索引，这样可以极大提高表连接的效率
- where条件字段上需要建立索引
- 排序字段上需要建立索引
- 分组字段上需要建立索引
- Where条件上不要使用运算函数，以免索引失效


### [读写分离-Gaea中间件](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650126388&idx=2&sn=d5e4ae86bc4fd2818ac5f30f8e7c460d&chksm=f36ba515c41c2c03de660b6f1b53abf41791621eb2c6b40b50b02a5b950495e3dbd889d91125&mpshare=1&scene=1&srcid=&sharer_sharetime=1582162650089&sharer_shareid=936076bf8d5bee83e89fd7e769b5c6db&key=d6442b0c53190ce2ab82fdac568e089b6f3249d21c244fd4b32c6858dd5d809072180d2da3a94bd7d758a5ef87e9703942aae33e66848e7056f9763d55531f719252c35e34abadf24ea5cb9368c38772&ascene=1&uin=MTg4MzA0MzMxNA%3D%3D&devicetype=Windows+7&version=62070158&lang=zh_CN&exportkey=AS%2Bxr6H5%2B83KMc7qNUgUrLA%3D&pass_ticket=z48jcWuYFwgYSdUAmAJt0cDA80oo272uZTTW3YNPJ8nj1WhovoGfUxL0JbKGc9Ed)

```mysql

```



